import type {BindParameters, BindParameter} from 'oracledb';
import type {ExecuteCallback} from '../src/backend/util/oracledb-provider.ts';

/**
 * Check if procedure name matches JSON response pattern.
 *
 * @param name - Procedure name.
 * @returns True if should return JSON.
 */
const isProcedureJson = (name: string): boolean => {
	const lower = name.toLowerCase();
	// Only match .getJson, .getData, or api.json specifically
	return /\.(?:getjson|getdata)$/i.test(lower) || lower === 'api.json';
};

/**
 * Check if procedure is from the special "$" package.
 *
 * @param name - Procedure name.
 * @returns True if starts with "$.";
 */
const isSpecialPackage = (name: string): boolean => {
	return name.toLowerCase().startsWith('$.');
};

/**
 * Get procedure name from special package.
 *
 * @param name - Full procedure name.
 * @returns Procedure name without prefix.
 */
const getSpecialProcedure = (name: string): string => {
	return name.toLowerCase().replace('$.', '');
};

/**
 * Check if procedure is from the "api" package.
 *
 * @param name - Procedure name.
 * @returns True if starts with "api.";
 */
const isApiPackage = (name: string): boolean => {
	return name.toLowerCase().startsWith('api.');
};

/**
 * Get procedure name from api package.
 *
 * @param name - Full procedure name.
 * @returns Procedure name without prefix.
 */
const getApiProcedure = (name: string): string => {
	return name.toLowerCase().replace('api.', '');
};

/**
 * Generate help page for $.help.
 *
 * @returns Array of response lines.
 */
const generateHelpPage = (): string[] => {
	return [
		'Content-Type: text/html\n',
		'\n',
		'<!DOCTYPE html>\n',
		'<html>\n',
		'<head><title>web_plsql Mock Server</title></head>\n',
		'<body>\n',
		'  <h1>web_plsql Mock Server</h1>\n',
		'  <p>Call any procedure to see a dynamic response with your parameters.</p>\n',
		'  \n',
		'  <h2>Examples</h2>\n',
		'  <ul>\n',
		'    <li><a href="/sample/mypackage.myproc?id=123&name=test">/sample/mypackage.myproc?id=123&name=test</a> - Generic HTML page</li>\n',
		'    <li><a href="/sample/api.html">/sample/api.html</a> - Sample HTML content</li>\n',
		'    <li><a href="/sample/api.json">/sample/api.json</a> - Sample JSON content</li>\n',
		'    <li><a href="/sample/api.files">/sample/api.files</a> - Download sample text file</li>\n',
		'  </ul>\n',
		'  \n',
		'  <h2>Special Mock URLs ($ package)</h2>\n',
		'  <ul>\n',
		'    <li><a href="/sample/$.help">/sample/$.help</a> - This help page</li>\n',
		'    <li><a href="/sample/$.health">/sample/$.health</a> - Server health status (JSON)</li>\n',
		'  </ul>\n',
		'  \n',
		'  <h2>Error Simulation (_mock_.* package)</h2>\n',
		'  <ul>\n',
		'    <li><a href="/sample/_mock_.not_found">/sample/_mock_.not_found</a> - ORA-06564: procedure doesn\'t exist</li>\n',
		'    <li><a href="/sample/_mock_.validation_error?test=1">/sample/_mock_.validation_error</a> - requestValidationFunction rejects</li>\n',
		'    <li><a href="/sample/_mock_.db_error">/sample/_mock_.db_error</a> - ORA-01017: connection error</li>\n',
		'    <li><a href="/sample/_mock_.timeout">/sample/_mock_.timeout</a> - Simulate hanging request (will timeout)</li>\n',
		'    <li><a href="/sample/_mock_.slow?ms=3000">/sample/_mock_.slow?ms=3000</a> - Delay response by 3 seconds</li>\n',
		'  </ul>\n',
		'  \n',
		'  <h2>Admin Console</h2>\n',
		'  <ul>\n',
		'    <li><a href="/admin/">/admin/</a> - Admin Console (backend)</li>\n',
		'    <li>Frontend dev: <a href="http://localhost:5173/admin/">http://localhost:5173/admin/</a></li>\n',
		'  </ul>\n',
		'  \n',
		'  <h2>Static Assets</h2>\n',
		'  <ul>\n',
		'    <li><a href="/static/sample.txt">/static/sample.txt</a> - Static text file</li>\n',
		'  </ul>\n',
		'</body>\n',
		'</html>\n',
	];
};

/**
 * Generate health page for $.health.
 *
 * @returns Array of response lines.
 */
const generateHealthPage = (): string[] => {
	const response = {
		status: 'ok',
		version: 'dev',
		mode: 'development',
		mock: true,
		timestamp: new Date().toISOString(),
	};
	const jsonLines = JSON.stringify(response, null, 2).split('\n');
	return ['Content-Type: application/json\n', '\n', ...jsonLines.map((l) => l + '\n')];
};

/**
 * Generate sample HTML for api.html.
 *
 * @returns Array of response lines.
 */
const generateApiHtml = (): string[] => {
	return [
		'Content-Type: text/html\n',
		'\n',
		'<!DOCTYPE html>\n',
		'<html>\n',
		'<head><title>Sample HTML from api.html</title></head>\n',
		'<body>\n',
		'  <h1>Sample HTML Content</h1>\n',
		'  <p>This is generated by <code>api.html</code> procedure.</p>\n',
		'  <ul>\n',
		'    <li>Item 1</li>\n',
		'    <li>Item 2</li>\n',
		'    <li>Item 3</li>\n',
		'  </ul>\n',
		'  <p><a href="/sample/$.help">Back to Help</a></p>\n',
		'</body>\n',
		'</html>\n',
	];
};

/**
 * Generate sample JSON for api.json.
 *
 * @returns Array of response lines.
 */
const generateApiJson = (): string[] => {
	const data = {
		status: 'success',
		message: 'Sample JSON from api.json',
		data: {
			users: ['Alice', 'Bob', 'Charlie'],
			count: 3,
		},
		timestamp: new Date().toISOString(),
	};
	const jsonLines = JSON.stringify(data, null, 2).split('\n');
	return ['Content-Type: application/json\n', '\n', ...jsonLines.map((l) => l + '\n')];
};

/**
 * Generate file download for api.files.
 *
 * @returns Array of response lines.
 */
const generateApiFiles = (): string[] => {
	const content = 'This is a sample file downloaded from api.files\nGenerated by web_plsql mock server.\n';
	return [
		'Content-Type: text/plain\n',
		'Content-Disposition: attachment; filename="sample.txt"\n',
		`X-DB-Content-Length: ${content.length}\n`,
		'\n',
		content,
	];
};

/**
 * Check if procedure is a mock error simulation.
 *
 * @param name - Procedure name.
 * @returns True if _mock_.* pattern.
 */
const isMockError = (name: string): boolean => {
	return name.toLowerCase().startsWith('_mock_.');
};

/**
 * Extract mock error type from procedure name.
 *
 * @param name - Procedure name like "_mock_.not_found".
 * @returns Error type like "not_found".
 */
const getMockErrorType = (name: string): string => {
	return name.toLowerCase().replace('_mock_.', '');
};

/**
 * Generate dynamic HTML page showing procedure and parameters.
 *
 * @param procedureName - The procedure name.
 * @param params - Query parameters.
 * @param method - HTTP method.
 * @returns Array of response lines.
 */
const generateDynamicHtmlPage = (procedureName: string, params: Record<string, unknown>, method: string): string[] => {
	const paramRows = Object.entries(params)
		.map(([key, value]) => {
			const type = typeof value;
			const valueStr = Array.isArray(value) ? JSON.stringify(value) : String(value);
			return `    <tr><td>${key}</td><td>${valueStr}</td><td>${type}</td></tr>`;
		})
		.join('\n');

	const hasParams = Object.keys(params).length > 0;

	return [
		'Content-Type: text/html\n',
		'\n',
		'<!DOCTYPE html>\n',
		'<html>\n',
		'<head>\n',
		`  <title>Mock: ${procedureName}</title>\n`,
		'  <style>\n',
		'    body { font-family: Arial, sans-serif; margin: 20px; }\n',
		'    table { border-collapse: collapse; margin: 20px 0; }\n',
		'    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n',
		'    th { background-color: #f2f2f2; font-weight: bold; }\n',
		'    .info { background-color: #e7f3ff; padding: 10px; border-left: 4px solid #2196F3; margin: 20px 0; }\n',
		'  </style>\n',
		'</head>\n',
		'<body>\n',
		`  <h1>Mock Procedure: ${procedureName}</h1>\n`,
		'  <div class="info">\n',
		`    <strong>Method:</strong> ${method}<br>\n`,
		`    <strong>Timestamp:</strong> ${new Date().toISOString()}\n`,
		'  </div>\n',
		'  <h2>Parameters</h2>\n',
		hasParams ? `  <table>\n    <tr><th>Name</th><th>Value</th><th>Type</th></tr>\n${paramRows}\n  </table>` : '  <p><em>No parameters provided</em></p>\n',
		'  <p><a href="/sample/$.help">‚Üê Back to Help</a></p>\n',
		'</body>\n',
		'</html>\n',
	];
};

/**
 * Generate JSON response.
 *
 * @param procedureName - The procedure name.
 * @param params - Query parameters.
 * @param method - HTTP method.
 * @returns Array of response lines.
 */
const generateJsonResponse = (procedureName: string, params: Record<string, unknown>, method: string): string[] => {
	const response = {
		status: 'success',
		procedure: procedureName,
		method: method,
		parameters: params,
		timestamp: new Date().toISOString(),
	};

	const jsonString = JSON.stringify(response, null, 2);

	// Split JSON into individual lines for OWA compatibility
	const jsonLines = jsonString.split('\n');

	return ['Content-Type: application/json\n', '\n', ...jsonLines.map((l) => l + '\n')];
};

/**
 * Simulate various error conditions.
 *
 * @param errorType - Type of error to simulate.
 * @param params - Query parameters (for extracting ms for slow).
 * @returns Delay info for slow simulation.
 * @throws Error for other error types.
 */
const simulateError = (errorType: string, params: Record<string, unknown>): {delay?: number} => {
	switch (errorType) {
		case 'not_found':
			throw new Error('ORA-06564: object _MOCK_.NOT_FOUND does not exist');

		case 'db_error':
			throw new Error('ORA-01017: invalid username/password; logon denied');

		case 'validation_error':
			// Will be handled by mock returning valid=0
			throw new Error('VALIDATION_ERROR');

		case 'timeout':
			// Simulate hanging - return empty response
			throw new Error('TIMEOUT_SIMULATION');

		case 'slow': {
			// Extract delay from params
			const msVal = params.ms;
			const ms = parseInt(typeof msVal === 'string' ? msVal : typeof msVal === 'number' ? String(msVal) : '2000', 10);
			return {delay: ms};
		}

		default:
			throw new Error(`Unknown mock error type: ${errorType}`);
	}
};

/**
 * Create SQL execution callback for mock PL/SQL procedures.
 *
 * @returns The execute callback function.
 */
export const createMockProcedureCallback = (): ExecuteCallback => {
	// Track last executed procedure and its response
	let lastProcedureName = '';
	let lastParams: Record<string, unknown> = {};
	let lastMethod = 'GET';
	let lastResponse: string[] = [];
	let delayMs = 0;

	// eslint-disable-next-line @typescript-eslint/require-await
	return async (sql: string, bindParams?: BindParameters) => {
		const sqlLower = sql.toLowerCase();

		// STRATEGY: Check bind parameter structure FIRST (most reliable)
		// Then confirm with SQL content as secondary check

		// ============================================================================
		// 1. PROCEDURE NAME RESOLUTION (procedureSanitize.ts resolveProcedureName)
		// ============================================================================
		// SQL: DECLARE ... BEGIN dbms_utility.name_resolve(...); :resolved := l_schema || '.' || l_part1 || '.' || l_part2; END;
		// Bind: {name: IN, resolved: OUT}
		if (bindParams && 'resolved' in bindParams && 'name' in bindParams && !('names' in bindParams)) {
			const nameParam = bindParams.name as BindParameter;
			const nameVal: unknown = nameParam?.val;
			const procName = (typeof nameVal === 'string' ? nameVal : '').toLowerCase();

			// Check for _mock_.not_found - throw error immediately
			if (procName === '_mock_.not_found') {
				throw new Error(`ORA-06564: object ${procName.toUpperCase()} does not exist`);
			}

			// All other procedures "exist" - return the same name as resolved
			return {
				outBinds: {
					resolved: procName,
				},
			};
		}

		// ============================================================================
		// 2. PARAMETER INTROSPECTION (procedureNamed.ts SQL_GET_ARGUMENT)
		// ============================================================================
		// SQL: DECLARE ... BEGIN dbms_utility.name_resolve(...); SELECT ... INTO :names, :types FROM all_arguments; END;
		// Bind: {name: IN, names: OUT array, types: OUT array}
		if (bindParams && 'names' in bindParams && 'types' in bindParams && 'name' in bindParams) {
			// Return empty params - all procedures accept arbitrary params in our mock
			return {
				outBinds: {
					names: [],
					types: [],
				},
			};
		}

		// ============================================================================
		// 3. REQUEST VALIDATION FUNCTION (procedureSanitize.ts loadRequestValid)
		// ============================================================================
		// SQL: DECLARE l_valid NUMBER := 0; BEGIN IF (validation_func(:proc)) THEN l_valid := 1; END IF; :valid := l_valid; END;
		// Bind: {proc: IN, valid: OUT}
		if (bindParams && 'valid' in bindParams && 'proc' in bindParams) {
			const procParam = bindParams.proc as BindParameter;
			const procName: unknown = procParam?.val;
			const procNameStr = typeof procName === 'string' ? procName.toLowerCase() : '';

			// Check if this is _mock_.validation_error - return invalid
			if (procNameStr === '_mock_.validation_error') {
				return {
					outBinds: {
						valid: 0, // Invalid
					},
				};
			}

			// All other procedures are valid
			return {
				outBinds: {
					valid: 1,
				},
			};
		}

		// ============================================================================
		// 4. SESSION INITIALIZATION (procedure.ts procedurePrepare)
		// ============================================================================
		// SQL: BEGIN dbms_session.modify_package_state(dbms_session.reinitialize); END;
		if (sqlLower.includes('dbms_session.modify_package_state')) {
			return {};
		}

		// ============================================================================
		// 5. CGI ENVIRONMENT SETUP (procedure.ts procedurePrepare)
		// ============================================================================
		// SQL: BEGIN owa.init_cgi_env(...); END;
		if (sqlLower.includes('owa.init_cgi_env')) {
			return {};
		}

		// ============================================================================
		// 6. PAGE CONTENT RETRIEVAL (procedure.ts procedureGetPage)
		// ============================================================================
		// SQL: BEGIN owa.get_page(thepage=>:lines, irows=>:irows); END;
		// Bind: {lines: OUT array, irows: OUT/INOUT number}
		// CHECK THIS BEFORE PROCEDURE EXECUTION to avoid false positive
		if (bindParams && 'lines' in bindParams && 'irows' in bindParams) {
			// Apply delay if set (for _mock_.slow)
			if (delayMs > 0) {
				const start = Date.now();
				while (Date.now() - start < delayMs) {
					// Busy wait (not ideal but works for mock)
				}
				delayMs = 0; // Reset
			}

			return {
				outBinds: {
					lines: lastResponse,
					irows: lastResponse.length,
				},
			};
		}

		// ============================================================================
		// 7. PROCEDURE EXECUTION (procedure.ts procedureExecute)
		// ============================================================================
		// SQL: BEGIN schema.package.procedure(:p_param1, :p_param2, ...); END;
		// Bind: {p_param1: IN, p_param2: IN, ...}
		if (sqlLower.includes('begin') && sqlLower.includes('end') && !sqlLower.includes('declare')) {
			// Extract procedure name from SQL
			// Patterns: BEGIN schema.proc(...) or BEGIN proc(...)
			const beginMatch = /BEGIN\s+([\w.$]+)/i.exec(sql);
			if (beginMatch?.[1]) {
				lastProcedureName = beginMatch[1];

				// Extract parameters from bindParams (skip special ones)
				lastParams = {};
				if (bindParams) {
					for (const [key, value] of Object.entries(bindParams)) {
						if (key.startsWith('p_')) {
							const paramName = key.substring(2); // Remove 'p_' prefix
							// NOTE: assuming value is BindParameter for now as that is what our procedure handlers use
							const param = value as BindParameter;
							lastParams[paramName] = param.val;
						}
					}
				}

				// Detect HTTP method from CGI env if available
				lastMethod = 'GET'; // Default

				// Check if this is a mock error
				if (isMockError(lastProcedureName)) {
					const errorType = getMockErrorType(lastProcedureName);

					// Special handling for slow - set delay
					if (errorType === 'slow') {
						const result = simulateError(errorType, lastParams);
						delayMs = result.delay ?? 0;
						// Generate normal HTML page after delay
						lastResponse = generateDynamicHtmlPage(lastProcedureName, lastParams, lastMethod);
						return {};
					}

					// For timeout, just return empty and never provide content
					if (errorType === 'timeout') {
						lastResponse = []; // Never return content
						return {};
					}

					// Other errors will throw during execution
					simulateError(errorType, lastParams);
				}

				// Check for Special Package ($)
				if (isSpecialPackage(lastProcedureName)) {
					const proc = getSpecialProcedure(lastProcedureName);
					if (proc === 'health') {
						lastResponse = generateHealthPage();
					} else {
						// Default to help for 'help' or any unknown special proc
						lastResponse = generateHelpPage();
					}
					return {};
				}

				// Check for API Package
				if (isApiPackage(lastProcedureName)) {
					const proc = getApiProcedure(lastProcedureName);
					if (proc === 'html') {
						lastResponse = generateApiHtml();
					} else if (proc === 'json') {
						lastResponse = generateApiJson();
					} else if (proc === 'files') {
						lastResponse = generateApiFiles();
					} else if (isProcedureJson(lastProcedureName)) {
						lastResponse = generateJsonResponse(lastProcedureName, lastParams, lastMethod);
					} else {
						// Default API response if unknown
						lastResponse = generateApiHtml();
					}
					return {};
				}

				// Check if default page (no procedure name)
				if (!lastProcedureName || lastProcedureName === '') {
					lastResponse = generateHelpPage();
					return {};
				}

				// Generate response based on procedure pattern
				if (isProcedureJson(lastProcedureName)) {
					lastResponse = generateJsonResponse(lastProcedureName, lastParams, lastMethod);
				} else {
					lastResponse = generateDynamicHtmlPage(lastProcedureName, lastParams, lastMethod);
				}

				return {};
			}

			// Fallback: couldn't extract procedure name
			lastResponse = generateHelpPage();
			return {};
		}

		// ============================================================================
		// 8. FILE DOWNLOAD (procedure.ts procedureDownloadFiles)
		// ============================================================================
		// SQL: BEGIN wpg_docload.get_download_file(...); END;
		if (sqlLower.includes('wpg_docload.get_download_file')) {
			return {
				outBinds: {
					fileType: '',
					fileSize: 0,
					fileBlob: null,
				},
			};
		}

		// ============================================================================
		// 9. FILE UPLOAD (file upload handler)
		// ============================================================================
		// SQL: INSERT INTO ...
		if (sqlLower.startsWith('insert into')) {
			return {
				rowsAffected: 1,
			};
		}

		// ============================================================================
		// UNHANDLED SQL - Log for debugging
		// ============================================================================
		console.warn('[MockProcedures] Unhandled SQL pattern:');
		console.warn('  SQL:', sql.substring(0, 300));
		console.warn('  Bind params:', bindParams ? Object.keys(bindParams).join(', ') : 'none');
		console.warn('  Has lines:', bindParams ? 'lines' in bindParams : false);
		console.warn('  Has irows:', bindParams ? 'irows' in bindParams : false);

		// Return empty result as fallback
		return {};
	};
};
